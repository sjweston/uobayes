p2 <- d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_line( aes(y=.epred, group=.draw),
data=filter(post2, .draw <= 20),
color = "black",
alpha=.3) +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m2")
p1 + p2
#| code-line-numbers: "7"
m2r <- brm(
data=d,
family=gaussian,
brain_std ~ mass_std + I(mass_std^2) + I(mass_std^3) +
I(mass_std^4) + I(mass_std^5),
prior = c( prior(normal(.5, 1), class=Intercept),
prior(normal(0, 1), class=b),
prior(exponential(1), class=sigma)),
iter=2000, warmup=1000, seed=5, chains=1,
file=here("files/models/41.2r"))
post2r = add_epred_draws(m2r, newdata = nd) # get predicted vals (expected means)
p2r <- d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_line( aes(y=.epred, group=.draw),
data=filter(post2r, .draw <= 20),
color = "black",
alpha=.3) +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m2 - regularized")
p2 + p2r
avg_line = colMeans(post1)
avg_line
avg_line$b_Intercept
avg_line["b_Intercept"]
d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_abline( aes(intercept=b_Intercept, slope=b_mass_std),
data=post1[1:20, ],
alpha=.3) +
geom_abline( intercept=avg_line["b_Intercept"], slope=avg_line["b_mass_std"]) +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m1")
#| code-fold: true
post1 = as_draws_df(m1) # get posterior distribution
avg_line = colMeans(post1)
p1 <- d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_abline( aes(intercept=b_Intercept, slope=b_mass_std),
data=post1[1:20, ],
alpha=.3) +
geom_abline( intercept=avg_line["b_Intercept"], slope=avg_line["b_mass_std"],
color = "#1c5253") +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m1")
nd = data.frame(mass_std = seq(min(d$mass_std), max(d$mass_std), length.out=1000))
post2 = add_epred_draws(m2, newdata = nd) # get predicted vals (expected means)
p2 <- d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_line( aes(y=.epred, group=.draw),
data=filter(post2, .draw <= 20),
color = "black",
alpha=.3) +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m2")
p1 + p2
#| code-fold: true
post1 = as_draws_df(m1) # get posterior distribution
avg_line = colMeans(post1)
p1 <- d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_abline( aes(intercept=b_Intercept, slope=b_mass_std),
data=post1[1:20, ],
alpha=.2) +
geom_abline( intercept=avg_line["b_Intercept"], slope=avg_line["b_mass_std"],
color = "#1c5253") +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m1")
nd = data.frame(mass_std = seq(min(d$mass_std), max(d$mass_std), length.out=1000))
post2 = add_epred_draws(m2, newdata = nd) # get predicted vals (expected means)
p2 <- d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_line( aes(y=.epred, group=.draw),
data=filter(post2, .draw <= 20),
color = "black",
alpha=.3) +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m2")
p1 + p2
post2
avg_line = post2 %>% with_groups(mass_std, summarise, m = mean(.epred))
p2 <- d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_line( aes(y=.epred, group=.draw),
data=filter(post2, .draw <= 20),
color = "black",
alpha=.3) +
geom_smooth( aes(y=m), data=avg_line, se=F) +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m2")
p1 + p2
p2 <- d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_line( aes(y=.epred, group=.draw),
data=filter(post2, .draw <= 20),
color = "black",
alpha=.3) +
geom_smooth( aes(y=m), data=avg_line, se=F, color="#1c5253") +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m2")
p2 <- d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_line( aes(y=.epred, group=.draw),
data=filter(post2, .draw <= 20),
color = "black",
alpha=.3) +
geom_smooth( aes(y=m), data=avg_line, se=F, colour="#1c5253") +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m2")
p1 + p2
#| code-fold: true
post1 = as_draws_df(m1) # get posterior distribution
avg_line = colMeans(post1)
p1 <- d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_abline( aes(intercept=b_Intercept, slope=b_mass_std),
data=post1[1:20, ],
alpha=.2) +
geom_abline( intercept=avg_line["b_Intercept"], slope=avg_line["b_mass_std"],
color = "#1c5253") +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m1")
nd = data.frame(mass_std = seq(min(d$mass_std), max(d$mass_std), length.out=1000))
post2 = add_epred_draws(m2, newdata = nd) # get predicted vals (expected means)
avg_line = post2 %>% with_groups(mass_std, summarise, m = mean(.epred))
p2 <- d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_line( aes(y=.epred, group=.draw),
data=filter(post2, .draw <= 20),
color = "black",
alpha=.2) +
geom_smooth( aes(y=m), data=avg_line, se=F, colour="#1c5253") +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m2")
p1 + p2
#| code-fold: true
nd = data.frame(mass_std = seq(min(d$mass_std), max(d$mass_std), length.out=1000))
post2 = add_epred_draws(m2, newdata = nd) # get predicted vals (expected means)
avg_line = post2 %>% with_groups(mass_std, summarise, m = mean(.epred))
p2 <- d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_line( aes(y=.epred, group=.draw),
data=filter(post2, .draw <= 20),
color = "black",
alpha=.2) +
geom_smooth( aes(y=m), data=avg_line, se=F, colour="#1c5253") +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m2")
post2r = add_epred_draws(m2r, newdata = nd) # get predicted vals (expected means)
avg_liner = post2r %>% with_groups(mass_std, summarise, m = mean(.epred))
p2r <- d %>%
ggplot( aes(x=mass_std, y=brain_std) ) +
geom_point() +
geom_line( aes(y=.epred, group=.draw),
data=filter(post2r, .draw <= 20),
color = "black",
alpha=.2) +
geom_smooth( aes(y=m), data=avg_liner, se=F, colour="#1c5253") +
lims(y=c(-3,6)) +
labs( x="mass (standardized)",
y="brain size (standardized)",
title="m2 - regularized")
p2 + p2r
loo(m1)
waic(m1)
m1  <- add_criterion(m1,  criterion = c("loo", "waic"))
m2  <- add_criterion(m2,  criterion = c("loo", "waic"))
m2r <- add_criterion(m2r, criterion = c("loo", "waic"))
loo_compare( m1, m2, m2r, criterion="loo")
loo_compare( m1, m2, m2r, criterion="waic")
## record current position
current = 10
## flip coin to generate proposal
(proposal <- current + sample( c(-1,1) , size=1 ))
## now make sure he loops around the archipelago
if ( proposal < 1 ) proposal <- 10
if ( proposal > 10 ) proposal <- 1
## move?
(prob_move <- proposal/current)
(current <- ifelse( runif(1) < prob_move , proposal , current ))
## record current position
current = 5
## record current position
current = 5
## flip coin to generate proposal
coin = (sample( c(-1,1) , size=1 ))
proposal = current + coin
## record current position
current = 5
## flip coin to generate proposal
(coin = sample( c(-1,1) , size=1 ))
proposal = current + coin
(proposal = current + coin)
## move?
(prob_move <- proposal/current)
runif(1)
## record current position
current = 5
## flip coin to generate proposal
(coin = sample( c(-1,1) , size=1 ))
(proposal = current + coin)
## move?
(prob_move <- proposal/current)
(current <- ifelse( runif(1) < prob_move , proposal , current ))
num_weeks <- 1e5
positions <- rep(0,num_weeks)
current <- 10
for ( i in 1:num_weeks ) {
## record current position
positions[i] <- current
## flip coin to generate proposal
proposal <- current + sample( c(-1,1) , size=1 )
## now make sure he loops around the archipelago
if ( proposal < 1 ) proposal <- 10
if ( proposal > 10 ) proposal <- 1
## move?
prob_move <- proposal/current
current <- ifelse( runif(1) < prob_move , proposal , current )
}
positions
data.frame(
weeks = 1:1e5,
positions) %>%
ggplot( aes(x=weeks, y=positions)) +
geom_line()
# Chunk 1
library(tidyverse)
library(psych)
library(cowplot)
library(patchwork)
library(here)
library(brms) ## NEW PACKAGE
library(tidybayes) ## NEW PACKAGE
# Chunk 2
knitr::opts_chunk$set(fig.retina=3, echo=TRUE)
theme_set(theme_cowplot())
default_palettes <- list(
c("#5e8485" , "#0f393a") ,
c("#1c5253" , "#5e8485" , "#0f393a") ,
# palette with 5 colours
c( "#1c5253" , "#e07a5f", "#f2cc8f" , "#81b29a" , "#3d405b" ) ,
# same palette interpolated to 8 colours
c( "#1c5253" , "#e07a5f", "#f2cc8f" , "#81b29a" , "#3d405b" , "#a7a844" , "#69306d" )
)
options(ggplot2.discrete.fill = default_palettes,
ggplot2.discrete.colour = default_palettes)
# Chunk 3
## record current position
current = 5
## flip coin to generate proposal
(coin = sample( c(-1,1) , size=1 ))
(proposal = current + coin)
## move?
(prob_move <- proposal/current)
(current <- ifelse( runif(1) < prob_move , proposal , current ))
# Chunk 4
num_weeks <- 1e5
positions <- rep(0,num_weeks)
current <- 10
for ( i in 1:num_weeks ) {
## record current position
positions[i] <- current
## flip coin to generate proposal
proposal <- current + sample( c(-1,1) , size=1 )
## now make sure he loops around the archipelago
if ( proposal < 1 ) proposal <- 10
if ( proposal > 10 ) proposal <- 1
## move?
prob_move <- proposal/current
current <- ifelse( runif(1) < prob_move , proposal , current )
}
data.frame(
weeks = 1:1e5,
positions) %>%
ggplot( aes(x=weeks, y=positions)) +
geom_line()
data.frame(
weeks = 1:1e5,
positions) %>%
ggplot( aes(x=weeks, y=positions)) +
geom_point()
data.frame(weeks = 1:1e5,positions) %>%
filter(weeks <=100) %>%
ggplot( aes(x=weeks, y=positions)) +
geom_line()
# Chunk 1
library(tidyverse)
library(psych)
library(cowplot)
library(patchwork)
library(here)
library(brms) ## NEW PACKAGE
library(tidybayes) ## NEW PACKAGE
# Chunk 2
knitr::opts_chunk$set(fig.retina=3, echo=TRUE)
theme_set(theme_cowplot())
default_palettes <- list(
c("#5e8485" , "#0f393a") ,
c("#1c5253" , "#5e8485" , "#0f393a") ,
# palette with 5 colours
c( "#1c5253" , "#e07a5f", "#f2cc8f" , "#81b29a" , "#3d405b" ) ,
# same palette interpolated to 8 colours
c( "#1c5253" , "#e07a5f", "#f2cc8f" , "#81b29a" , "#3d405b" , "#a7a844" , "#69306d" )
)
options(ggplot2.discrete.fill = default_palettes,
ggplot2.discrete.colour = default_palettes)
# Chunk 3
## record current position
current = 5
## flip coin to generate proposal
(coin = sample( c(-1,1) , size=1 ))
(proposal = current + coin)
## move?
(prob_move <- proposal/current)
(current <- ifelse( runif(1) < prob_move , proposal , current ))
# Chunk 4
num_weeks <- 1e5
positions <- rep(0,num_weeks)
current <- 10
for ( i in 1:num_weeks ) {
## record current position
positions[i] <- current
## flip coin to generate proposal
proposal <- current + sample( c(-1,1) , size=1 )
## now make sure he loops around the archipelago
if ( proposal < 1 ) proposal <- 10
if ( proposal > 10 ) proposal <- 1
## move?
prob_move <- proposal/current
current <- ifelse( runif(1) < prob_move , proposal , current )
}
# Chunk 5
data.frame(weeks = 1:1e5,positions) %>%
filter(weeks <=100) %>%
ggplot( aes(x=weeks, y=positions)) +
geom_line()
# Chunk 6
data(Howell1, package = "rethinking")
d <- Howell1
library(measurements)
d$height <- conv_unit(d$height, from = "cm", to = "feet")
d$weight <- conv_unit(d$weight, from = "kg", to = "lbs")
describe(d, fast = T)
d <- d[d$age >= 18, ]
d$height_c <- d$height - mean(d$height)
# Chunk 7
#| code-line-numbers: "1,2"
#|
m42.1 <-brm(
data = d,
family = gaussian,
weight ~ 1 + height_c,
prior = c( prior( normal(130,20), class = Intercept),
prior( normal(0,25), class = b),
prior( uniform(0,50), class = sigma, ub = 50)
),
iter = 5000, warmup = 1000, chains = 4,
seed = 3,
file = here("files/data/generated_data/m42.1"))
# Chunk 1
library(tidyverse)
library(psych)
library(cowplot)
library(patchwork)
library(here)
library(brms) ## NEW PACKAGE
library(tidybayes) ## NEW PACKAGE
# Chunk 2
knitr::opts_chunk$set(fig.retina=3, echo=TRUE)
theme_set(theme_cowplot())
default_palettes <- list(
c("#5e8485" , "#0f393a") ,
c("#1c5253" , "#5e8485" , "#0f393a") ,
# palette with 5 colours
c( "#1c5253" , "#e07a5f", "#f2cc8f" , "#81b29a" , "#3d405b" ) ,
# same palette interpolated to 8 colours
c( "#1c5253" , "#e07a5f", "#f2cc8f" , "#81b29a" , "#3d405b" , "#a7a844" , "#69306d" )
)
options(ggplot2.discrete.fill = default_palettes,
ggplot2.discrete.colour = default_palettes)
# Chunk 3
## record current position
current = 5
## flip coin to generate proposal
(coin = sample( c(-1,1) , size=1 ))
(proposal = current + coin)
## move?
(prob_move <- proposal/current)
(current <- ifelse( runif(1) < prob_move , proposal , current ))
# Chunk 4
num_weeks <- 1e5
positions <- rep(0,num_weeks)
current <- 10
for ( i in 1:num_weeks ) {
## record current position
positions[i] <- current
## flip coin to generate proposal
proposal <- current + sample( c(-1,1) , size=1 )
## now make sure he loops around the archipelago
if ( proposal < 1 ) proposal <- 10
if ( proposal > 10 ) proposal <- 1
## move?
prob_move <- proposal/current
current <- ifelse( runif(1) < prob_move , proposal , current )
}
# Chunk 5
data.frame(weeks = 1:1e5,positions) %>%
filter(weeks <=100) %>%
ggplot( aes(x=weeks, y=positions)) +
geom_line()
# Chunk 6
data(Howell1, package = "rethinking")
d <- Howell1
library(measurements)
d$height <- conv_unit(d$height, from = "cm", to = "feet")
d$weight <- conv_unit(d$weight, from = "kg", to = "lbs")
describe(d, fast = T)
d <- d[d$age >= 18, ]
d$height_c <- d$height - mean(d$height)
# Chunk 7
#| code-line-numbers: "1,2"
#|
m1 <-brm(
data = d,
family = gaussian,
weight ~ 1 + height_c,
prior = c( prior( normal(130,20), class = Intercept),
prior( normal(0,25), class = b),
prior( uniform(0,50), class = sigma, ub = 50)
),
iter = 5000, warmup = 1000, chains = 4,
seed = 3,
file = here("files/data/generated_data/m1"))
#| code-line-numbers: "3"
#|
m1 <-brm(
data = d,
family = gaussian,
weight ~ 1 + height_c,
prior = c( prior( normal(130,20), class = Intercept),
prior( normal(0,25), class = b),
prior( uniform(0,50), class = sigma, ub = 50)
),
iter = 5000, warmup = 1000, chains = 4,
seed = 3,
file = here("files/data/generated_data/m42.1"))
summary(m1)
brms::stancode(m1)
library(bayesplot)
mcmc_trace(m1)
mcmc_rank_overlay(m1)
mcmc_rank_overlay(m1, facet_args = scales="free")
mcmc_rank_overlay(m1, facet_args = list(scales="free"))
mcmc_rank_overlay(m1, facet_args = list(scales="free"))
?mcmc_rank_overlay
mcmc_rank_overlay(m1, "alpha")
mcmc_rank_overlay(m1, "beta")
mcmc_rank_overlay(m1, regex_pars = "beta")
mcmc_rank_overlay(m1)
mcmc_rank_overlay(m1, pars=vars(b_Intercept:sigma))
mcmc_rank_overlay(m1, pars=vars(b_Intercept:sigma), facet_args = list(scales="free"))
mcmc_rank_overlay(m1, pars=vars(b_Intercept:sigma), facet_args = list(scales="free_y"))
mcmc_rank_overlay(m1, pars=vars(b_Intercept:sigma)) +ylim(150, NA)
summary(m1)
