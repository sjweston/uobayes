---
title: "Week 2: Linear models and causal inference"
subtitle: "Categories and curves"
format: 
  revealjs:
    css: xaringan-themer2.css
    nature:
      highlightStyle: solarized-dark
      highlightLines: true
      countIncrementalSlides: false
      mathjax: "default"
    self-contained: false  # Ensures correct embedding
    embed-resources: true  # Embeds required assets
    slide-number: true
---

Workspace setup:

```{r, echo = T, message = F, warning = F}

library(tidyverse)
library(cowplot)
library(brms)
library(tidybayes)
library(patchwork)

```

```{r, echo = F}
knitr::opts_chunk$set(fig.retina=3, echo=TRUE)
theme_set(theme_cowplot())
default_palettes <- list(
  c("#5e8485" , "#0f393a") ,
  c("#1c5253" , "#5e8485" , "#0f393a") , 
  # palette with 5 colours
 c( "#1c5253" , "#e07a5f", "#f2cc8f" , "#81b29a" , "#3d405b" ) ,
  # same palette interpolated to 8 colours
 c( "#1c5253" , "#e07a5f", "#f2cc8f" , "#81b29a" , "#3d405b" , "#a7a844" , "#69306d" ) 
  
)

options(ggplot2.discrete.fill = default_palettes, 
        ggplot2.discrete.colour = default_palettes)
```

As we develop more useful models, we'll begin to practice the art of generating models with multiple estimands. An *estimand* is a quantity we want to estimate from the data. Our models may not themselves produce the answer to our central question, so we need to know how to calculate these values from the posterior distributions.

This is going to be different from prior regression courses (PSY 612), where our models were often designed to give us precisely what we wanted. For example, consider the regression:

$$
\hat{Y} = b_0 + b_1(D)
$$
Where $Y$ is a continuous outcome and $D$ is a dummy coded variable (0 = control; 1 = treatment).

  * What does $b_0$ represent? 
  * What does $b_1$ represent? 
  * How would you calculate or estimate the means of both groups from this model?

------------------------------------------------------------------------

## Categories

Forget dummy codes. From here on out, we will incorporate categorical causes into our models by using index variables. An **index variable** contains integers that correspond to different categories. The numbers have no inherent meaning -- rather, they stand as placeholders or shorthand for categories.

```{r}
data("Howell1", package = "rethinking")
d <- Howell1
library(measurements)
d$height <- conv_unit(d$height, from = "cm", to = "feet")
d$weight <- conv_unit(d$weight, from = "kg", to = "lbs")
d <- d[d$age >= 18, ]
d$sex <- ifelse(d$male == 1, 2, 1) # 1 = female, 2 = male
d$sex <- factor(d$sex)
head(d[, c("male", "sex")])
```

------------------------------------------------------------------------

### Mathematical model

Let's write a mathematical model to express weight in terms of sex.

\begin{align*}
w_i &\sim \text{Normal}(\mu_i, \sigma) \\
\mu_i &=     \alpha_{SEX[i]} \\
\alpha_j &\sim \text{Normal}(130, 20)\text{ for }j = 1..2 \\
\sigma &\sim \text{Uniform}(0, 25)
\end{align*}


### Fitting the model using `brms()`

```{r}
m1 <- brm(
  data = d,
  family = gaussian,
  weight ~ 0 + sex,
  prior = c(prior( normal(130, 20), class=b),
            prior( uniform(0, 25),  class=sigma, ub=25)),
  iter = 2000, warmup = 1000, seed = 3, chains=1,
  file = here("files/models/22.1")
)
posterior_summary(m1)
```

Here, we are given the estimates of the parameters specified in our model: the average weight of women (`b_sex1`) and the average weight of men (`b_sex2`). But our question is whether these average weights are different. How do we get that?

------------------------------------------------------------------------

```{r}
post = as_draws_df(m1) 
post %>% 
  mutate(diff_fm = b_sex1 - b_sex2) %>% 
  pivot_longer(cols = c(b_sex1:sigma, diff_fm)) %>% 
  group_by(name) %>% 
  mean_qi(value, .width = .89)
```

------------------------------------------------------------------------

### Calculate the contrast

We can create two plots. One is the posterior distributions of average female and male weights and one is the average difference.

```{r post-sex, eval = F}

p1 <- post %>% 
  pivot_longer(starts_with("b")) %>% 
  mutate(sex = ifelse(str_detect(name, "1"), "female", "male")) %>% 
  ggplot(aes(x=value, color = sex)) +
  geom_density(linewidth = 2) +
  labs(x = "weight(lbs)") 

p2 <- post %>% 
  mutate(diff_fm = b_sex1 - b_sex2) %>%
  ggplot(aes(x=diff_fm)) +
  geom_density(linewidth = 2) +
  labs(x = "difference in weight(lbs)") 

( p1 | p2)
```

------------------------------------------------------------------------

```{r ref.label="post-sex", fig.weight=5, fig.width=8,  fig.align="center", echo =F}

```

------------------------------------------------------------------------

### Expected values vs predicted values

A note that the distributions of the *mean* weights is not the same as the distribution of weights period. For that, we need the posterior predictive distributions. Here are two methods for getting predicted values. 

First, simulate using the `rnorm()`function. This is more intuitive and will help you mentally reconnect the parameters of your statistical model with the causal model you started with. But there's more room for human error.

```{r post-sex2}

pred_f  <- rnorm(nrow(post), mean = post$b_sex1, sd = post$sigma )
pred_m  <- rnorm(nrow(post), mean = post$b_sex2, sd = post$sigma )

pred_post = data.frame(pred_f, pred_m) %>%
  mutate(diff = pred_f-pred_m)
head(pred_post)
```

Second, use the `predicted_draws()` function. This is less intuitive, but there's less room for you to make a mistake. 

```{r}
nd = distinct(d, sex)
pred_all = predicted_draws(object=m1, newdata=nd) %>% 
  ungroup %>% select(-.row) %>% 
  pivot_wider(names_from = sex, names_prefix = "sex", values_from = .prediction) %>% 
  mutate(diff = sex1-sex2)
head(pred_all)
```

---

```{r, fig.align = "center"}
#| code-fold: true
# plot male and female distributions using the first version
p1 <- pred_post %>% pivot_longer(starts_with("pred")) %>% 
  mutate(sex = ifelse(name == "pred_f", "female", "male")) %>% 
  ggplot(aes(x = value, color = sex)) +
  geom_density(linewidth = 2) +
  labs(x = "weight (lbs)")

# plot difference distribution using the second version
# Compute density first
density_data <- density(pred_all$diff)

# Convert to a tibble for plotting
density_df <- tibble(
  x = density_data$x,
  y = density_data$y,
  fill_group = ifelse(x < 0, "male", "female")  # Define fill condition
)

# Plot with area fill
p2 <- ggplot(density_df, aes(x = x, y = y, fill = fill_group)) +
  geom_area() +  # Adjust transparency if needed
  geom_line(linewidth = 1.2, color = "black") +  # Keep one continuous curve
  labs(x = "Difference in weight (F-M)", y = "density") +
  guides(fill = "none")

(p1 | p2)
```


------------------------------------------------------------------------

## exercise

In the `rethinking` package, the dataset `milk` contains information about the composition of milk across primate species, as well as some other facts about those species. The taxonomic membership of each species is included in the variable `clade`; there are four categories.

1.  Create variable in the dataset to assign an index value to each of the 4 categories.
2.  Standardize the milk energy variable (`kcal.per.g`). [^lecture02-2-1]
3.  Write a mathematical model to express the average milk energy (in standardized kilocalories) in each clade.

------------------------------------------------------------------------

### solution

```{r}
data("milk", package="rethinking")
str(milk)
milk$clade_id <- as.integer(milk$clade)
milk$clade_id <- as.factor(milk$clade_id)
milk$K <- standardize(milk$kcal.per.g)
```

\begin{align*}
K_i &\sim \text{Normal}(\mu_i, \sigma) \\
\mu_i &= \alpha_{\text{CLADE}[i]} \\
\alpha_i &\sim \text{Normal}(0, 0.5) \text{ for }j=1..4 \\
\sigma &\sim \text{Exponential}(1) \\
\end{align*}

**Exercise:** Now fit your model using `quap()`. It's ok if your mathematical model is a bit different from mine.

------------------------------------------------------------------------

### solution

```{r}
m2 <- brm(
  data=milk,
  family=gaussian,
  K ~ 0 + clade_id, 
  prior = c( prior(normal(0,.5), class=b),
             prior(exponential(1), class=sigma)),
  iter = 2000, warmup = 1000, seed = 3, chains=1,
  file = here("files/models/22.2")
)

posterior_summary(m2)
```


------------------------------------------------------------------------

### exercise

Plot the following distributions:

-   Posterior distribution of average milk energy by clade.
-   Posterior distribution of predicted milk energy values by clade.

------------------------------------------------------------------------

### solution

```{r}
post <- extract.samples( m2 )
names(labels) = paste("a.", 1:4, sep = "")
post %>% as.data.frame() %>% 
  pivot_longer(starts_with("a")) %>% 
  mutate(name = recode(name, !!!labels)) %>% 
  ggplot(aes(x = value, color = name)) +
  geom_density(linewidth = 2) +
  labs(title = "Posterior distribution of expected milk energy")
```

------------------------------------------------------------------------

### solution

```{r}
post <- extract.samples( m2 )
a.1 = rnorm(1e4, post$a[,1], post$sigma)
a.2 = rnorm(1e4, post$a[,2], post$sigma)
a.3 = rnorm(1e4, post$a[,3], post$sigma)
a.4 = rnorm(1e4, post$a[,4], post$sigma)
data.frame(a.1, a.2, a.3, a.4) %>% 
  pivot_longer(everything()) %>% 
  mutate(name = recode(name, !!!labels)) %>% 
  ggplot(aes(x = value, color = name)) +
  geom_density(linewidth = 2) +
  labs(title = "Posterior distribution of predicted milk energy")
```

------------------------------------------------------------------------

### Plotting with `brms` and `tidybayes`

```{r, fig.weight=5, fig.width=8}
as_draws_df(m2) %>% 
  pivot_longer(starts_with("b")) %>% 
  mutate(
    clade = str_extract(name, "[0-9]"),
    clade = as.numeric(clade),
    clade = factor(clade, labels=levels(milk$clade))
  ) %>%
  ggplot(aes(y = clade, x = value)) +
  stat_halfeye() +
  labs(x="mean", y=NULL)
```

------------------------------------------------------------------------

## Combining index variables and slopes

Let's return to the weight example. What if we want to control for height?

\begin{align*}
w_i &\sim \text{Normal}(\mu_i, \sigma) \\
\mu_i &= \alpha_{S[i]} + \beta_{S[i]}(H_i-\bar{H})\\
\alpha_j &\sim \text{Normal}(130, 20)\text{ for }j = 1..2 \\
\beta_j &\sim \text{Normal}(0, 25)\text{ for }j = 1..2 \\
\sigma &\sim \text{Uniform}(0, 50)
\end{align*}

::: fragment
```{r}
dat <- list(
  weight = d$weight,
  height = d$height,
  Hbar <- mean(d$height),
  sex = d$male + 1
)

flist <- alist(
  weight ~ dnorm( mu , sigma) ,
  mu <- a[sex] + b[sex]*(height-Hbar),
  a[sex] ~ dnorm( 150, 20 ) ,
  b[sex] ~ dnorm( 0, 25 ) ,
  sigma ~ dunif(0, 50)
)

m3 <- quap(flist, data=dat)
```
:::

------------------------------------------------------------------------

```{r}
precis(m3, depth=3)
post <- extract.samples(m3)
str(post)
```

------------------------------------------------------------------------

Plot the slopes using `extract.samples()`

```{r}
#| code-fold: true

xbar = mean(d$height) # need this because we centered
post <- extract.samples(m3) # sample intercepts and slopes from the posterior
plot(d$weight ~ d$height, cex=0.5, pch=16, col=col.alpha("darkgrey",0.5),
     xlab = "height", ylab = "weight")
#plot the lines implied by the first 50 draws from the posterior
for(i in 1:50){
 curve(post$a[i, 1] +post$b[i, 1]*(x-xbar), 
       add = T,
       col=col.alpha("#1c5253",0.1))  
  curve(post$a[i, 2] +post$b[i, 2]*(x-xbar), 
       add = T,
       col=col.alpha("#e07a5f",0.1))  
}
```

------------------------------------------------------------------------

Plot the slopes using `link()`. (Run this yourself and open up the objects `muF` and `muM` to determine what the `link()` function is doing.)

```{r}
#| code-fold: true  

xseq <- seq( min(d$height), max(d$height), len=100) # some values for X
plot(d$weight ~ d$height, cex=0.5, pch=16, col=col.alpha("darkgrey",0.3),
     xlim = range(d$height), ylim = range(d$weight), 
     xlab = "height", ylab = "weight")
muF <- link(m3, data=list(sex=rep(1,100), height=xseq, Hbar = mean(d$height)))
lines(xseq, apply(muF, 2, mean), lwd = 2, col = "#1c5253" )
muM <- link(m3, data=list(sex=rep(2,100), height=xseq, Hbar = mean(d$height)))
lines(xseq, apply(muM, 2, mean), lwd = 2, col =  "#e07a5f")
```

------------------------------------------------------------------------

### exercise

Return to the `milk` data. Write a mathematical model expressing the energy of milk as a function of the species body mass (`mass`) and clade category. Be sure to include priors. Fit your model using `quap()`.

------------------------------------------------------------------------

### solution

\begin{align*}
K_i &\sim \text{Normal}(\mu_i, \sigma) \\
\mu_i &= \alpha_{\text{CLADE}[i]} + \beta_{\text{CLADE}[i]}(M-\bar{M})\\
\alpha_i &\sim \text{Normal}(0, 0.5) \text{ for }j=1..4 \\
\beta_i &\sim \text{Normal}(0, 0.5) \text{ for }j=1..4 \\
\sigma &\sim \text{Exponential}(1) \\
\end{align*}

::: fragment
```{r}
dat <- list(
  K        = standardize(milk$kcal.per.g),
  M        = milk$mass,
  Mbar     = mean(milk$mass),
  clade_id = milk$clade_id
)

flist <- alist(
  K ~ dnorm( mu , sigma ) ,
  mu <- a[clade_id] +b[clade_id]*(M-Mbar), 
  a[clade_id] ~ dnorm( 0 , 0.5 ) , 
  b[clade_id] ~ dnorm( 0 , 0.5 ) , 
  sigma ~ dexp( 1 )
)

m4 <- quap(
  flist, data = dat
)
```
:::

------------------------------------------------------------------------

```{r}
precis( m4, depth=2 )
```

------------------------------------------------------------------------




::::: columns
::: {.column width="50%"}
```{r plot-apes, eval = F}
xseq <- seq( min(milk$mass), max(milk$mass), len=100)
Mbar = mean(milk$mass)
custom_colors = c("#1c5253", "#e07a5f", "#f2cc8f", "#81b29a")
colors = custom_colors[milk$clade_id]
plot(milk$K ~ milk$mass, col = colors, 
     pch = 16,
     xlim = range(milk$mass), ylim = range(milk$K), 
     xlab = "height", ylab = "weight")
mu1 <- 
  link(m4, data=list(clade_id=rep(1,100), M=xseq, Mbar = Mbar))
lines(xseq, apply(mu1, 2, mean), lwd = 2, col = "#1c5253" )
mu2 <- 
  link(m4, data=list(clade_id=rep(2,100), M=xseq, Mbar = Mbar))
lines(xseq, apply(mu2, 2, mean), lwd = 2, col = "#e07a5f" )
mu3 <- 
  link(m4, data=list(clade_id=rep(3,100), M=xseq, Mbar = Mbar))
lines(xseq, apply(mu3, 2, mean), lwd = 2, col = "#f2cc8f" )
mu4 <- 
  link(m4, data=list(clade_id=rep(4,100), M=xseq, Mbar = Mbar))
lines(xseq, apply(mu4, 2, mean), lwd = 2, col = "#81b29a" )
legend("topright", legend = levels(milk$clade), 
       col = custom_colors, pch = 16)

```
:::

::: {.column width="50%"}
```{r, ref.label="plot-apes", echo=F, fig.weight=12}

```

:::
:::::

[^lecture02-2-1]: You don't need to be an expert in primate biology to have a sense of what is reasonable for these values after we standardize.

