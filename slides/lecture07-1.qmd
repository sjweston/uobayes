---
title: "week 7: multilevel models"
subtitle: "multilevel adventures"
format: 
  revealjs:
    css: xaringan-themer2.css
    nature:
      highlightStyle: solarized-dark
      highlightLines: true
      countIncrementalSlides: false
      mathjax: "default"
    self-contained: false  # Ensures correct embedding
    embed-resources: true  # Embeds required assets
    slide-number: true
    code-annotations: hover
execute:
  echo: false        
---

```{r, message = F, warning = F}
library(tidyverse)
library(psych)
library(cowplot)
library(patchwork)
library(here)
library(brms) 
library(tidybayes) 
```

```{r, echo = F}
knitr::opts_chunk$set(fig.retina=3, echo=TRUE)
theme_set(theme_cowplot())
default_palettes <- list(
  c("#5e8485" , "#0f393a") ,
  c("#1c5253" , "#5e8485" , "#0f393a") , 
  # palette with 5 colours
 c( "#1c5253" , "#e07a5f", "#f2cc8f" , "#81b29a" , "#3d405b" ) ,
  # same palette interpolated to 8 colours
 c( "#1c5253" , "#e07a5f", "#f2cc8f" , "#81b29a" , "#3d405b" , "#a7a844" , "#69306d" ) 
  
)

options(ggplot2.discrete.fill = default_palettes, 
        ggplot2.discrete.colour = default_palettes)
```

---

## multilevel tadpoles

```{r}
data(reedfrogs, package = "rethinking")
d <- reedfrogs
dim(d)
d %>% sample_n(10)
```

---

Let's start with the unpooled model. Up to this point in the course, this would be a good model to use to estimate survival in each of the tanks. 

\begin{align*}
\text{surv}_i &\sim \text{Binomial}(n_i,p_i) \\
\text{logit}(p_i) &= \alpha_{\text{tank}[i]} \\
\alpha_j &\sim \text{Normal}(0, 1.5) \text{ for }j=1,...,48
\end{align*}

```{r}
d$tank = factor(1:nrow(d))

m1 <- 
  brm(data = d, 
      family = binomial,
      bf(surv | trials(density) ~ 0 + alpha, 
         alpha ~ 0 + tank, 
         nl = TRUE),
      prior(normal(0, 1.5), class = b, nlpar=alpha),
      iter = 2000, warmup = 1000, chains = 4, cores = 4,
      seed = 13,
      file = here("files/models/71.1"))
```

---

```{r}
print(m1)
```

---

```{r}
#| code-fold: true
# get posterior
post <- as_draws_df(m1)
# transform logit to probability
p1 <- post %>% 
  pivot_longer(starts_with("b_alpha"),
               names_prefix = "b_alpha_tank",
               values_to = "logit") %>% 
  mutate(prob = logistic(logit),
         tank = as.numeric(name)) %>% 
  ggplot( aes (x = tank, y = prob)) +
  stat_gradientinterval(alpha = .3, color="#5e8485") +
  geom_point( aes(x=as.numeric(tank), y=propsurv),
              data=d) +
  labs(title = "Unpooled model")
p1
```

---

Now let's build up the pooled (multilevel) model and see how it compares. 

\begin{align*}
\text{surv}_i &\sim \text{Binomial}(n_i,p_i) \\
\text{logit}(p_i) &= \alpha_{\text{tank}[i]} \\
\alpha_j &\sim \text{Normal}(\bar{\alpha}, \sigma) \\
\bar{\alpha} &\sim \text{Normal}(0, 1.5) \\
\sigma &\sim \text{Exponential}(1)
\end{align*}

```{r}
m2 <- 
  brm(data = d, 
      family = binomial,
      surv | trials(density) ~ 1 + (1 | tank),
      prior = c(prior(normal(0, 1.5), class = Intercept),  # alpha bar
                prior(exponential(1), class = sd)),        # sigma
      iter = 5000, warmup = 1000, chains = 4, cores = 4,
      sample_prior = "yes",
      seed = 13,
      file = here("files/models/71.2"))
```

---

```{r}
print(m2)
```

---

```{r}
posterior_summary(m2) %>% round(2)
```

---

The "intercepts" for each tank are actually the distance of that tank's intercept from the grand mean. 

```{r}
gather_draws(m2, r_tank[tank, ]) %>% 
  mean_qi() %>% 
  ggplot(aes( y=tank, x=.value )) +
  geom_point() +
  geom_errorbar( aes(xmin=.lower, xmax=.upper ), alpha=.5) +
  geom_vline(xintercept = 0) +
  labs(x="Varying intercepts")
```


---

```{r}
#| code-fold: true
m1 <- add_criterion(m1, "waic")
m2 <- add_criterion(m2, "waic")

w <- loo_compare(m1, m2, criterion = "waic")

print(w, simplify = F)
```

---

```{r}
#| code-fold: true
#average survival
post_sum = posterior_summary(m2)
average_surv = post_sum["b_Intercept", "Estimate"] 
p2 <- gather_draws(m2, r_tank[tank, Intercept]) %>% 
  mutate(prob = logistic(.value+average_surv)) %>% 
  ggplot( aes (x = tank, y = prob)) +
  stat_gradientinterval(alpha = .3, color="#5e8485") +
  geom_point( aes(x=as.numeric(tank), y=propsurv),
              data=d ) +
  geom_hline( aes(yintercept = logistic(average_surv)),
              linetype = "dashed")+
  labs(title = "Partial pooling model")

p2
```

---

```{r, echo = F, out.height="100%"}
p1 / p2
```

---

## Hyperparameter tuning

```{r}

# Try different priors for sigma (tank varying effects SD)
sigmas <- c(0.5, 1, 2, 4)
models <- list()

# Fit models with different priors
for(i in seq_along(sigmas)) {
  models[[i]] <- brm(
    surv | trials(density) ~ 1 + (1|tank),
    data = d,
    family = binomial,
    prior = c(
      prior(normal(0, 1.5), class = "Intercept"),
      prior(exponential(1/sigmas[i]), class = "sd")
    ),
    cores = 4,
    seed = 123
  )
  # Add WAIC criterion
  models[[i]] <- add_criterion(models[[i]], "waic")
}

# Compare models
waic_comp <- loo_compare(models[[1]], models[[2]], 
                        models[[3]], models[[4]], 
                        criterion = "waic")

# Print comparison
print(waic_comp, simplify = FALSE)

# Plot the varying intercepts for each model to visualize impact
plots <- list()
for(i in seq_along(models)) {
  plots[[i]] <- gather_draws(models[[i]], r_tank[tank,Intercept]) %>%
    ggplot(aes(y=tank, x=.value)) +
    geom_point() +
    geom_errorbar(aes(xmin=.lower, xmax=.upper), alpha=.5) +
    geom_vline(xintercept = 0) +
    labs(x="Varying intercepts",
         title=paste0("Prior sigma = ", sigmas[i]))
}

# Arrange plots in a grid
(plots[[1]] + plots[[2]]) / (plots[[3]] + plots[[4]])

```
