---
title: "week 7: multilevel models"
subtitle: "multilevel adventures"
format: 
  revealjs:
    css: xaringan-themer2.css
    nature:
      highlightStyle: solarized-dark
      highlightLines: true
      countIncrementalSlides: false
      mathjax: "default"
    self-contained: false  # Ensures correct embedding
    embed-resources: true  # Embeds required assets
    slide-number: true
    code-annotations: hover
execute:
  echo: false        
---

```{r, message = F, warning = F}
library(tidyverse)
library(psych)
library(cowplot)
library(patchwork)
library(here)
library(brms) 
library(tidybayes) 
```

```{r, echo = F}
knitr::opts_chunk$set(fig.retina=3, echo=TRUE)
theme_set(theme_cowplot())
default_palettes <- list(
  c("#5e8485" , "#0f393a") ,
  c("#1c5253" , "#5e8485" , "#0f393a") , 
  # palette with 5 colours
 c( "#1c5253" , "#e07a5f", "#f2cc8f" , "#81b29a" , "#3d405b" ) ,
  # same palette interpolated to 8 colours
 c( "#1c5253" , "#e07a5f", "#f2cc8f" , "#81b29a" , "#3d405b" , "#a7a844" , "#69306d" ) 
  
)

options(ggplot2.discrete.fill = default_palettes, 
        ggplot2.discrete.colour = default_palettes)
```


## divergent transitions

From McElreath:

> Recall that HMC simulates the frictionless flow of a particle on a surface. In any given transition, which is just a single flick of the particle, the total energy at the start should be equal to the total energy at the end. That’s how energy in a closed system works. And in a purely mathematical system, the energy is always conserved correctly. It’s just a fact about the physics.

> But in a numerical system, it might not be. Sometimes the total energy is not the same at the end as it was at the start. In these cases, the energy is divergent. How can this happen? It tends to happen when the posterior distribution is very steep in some region of parameter space. Steep changes in probability are hard for a discrete physics simulation to follow. When that happens, the algorithm notices by comparing the energy at the start to the energy at the end. When they don’t match, it indicates numerical problems exploring that part of the posterior distribution.

---

### centered parameterization

In his lecture, McElreath uses **CENTERED PARAMETERIZATION** to demonstrate divergent transitions. A very simple example:

\begin{align*}
x &\sim \text{Normal}(0, exp(\nu)) \\
\nu &\sim \text{Normal}(0, 3) \\
\end{align*}


This expression is centered because one set of priors (the priors for $x$) are centered around another prior (the prior for $\nu$). It's intuitive, but this can cause a lot of problems with Stan, which is probably why McElreath used this for his example. In short, when there is limited data within our groups or the population variance is small, the parameters $x$ and $\nu$ become highly correlated. This geometry is challenging for MCMC to sample. (Think of a long and narrow groove, not a bowl, for your Hamiltonian skateboard.)

---

```{r}
#| code-fold: true
set.seed(1)
# plot the likelihoods
ps <- seq( from=-4, to=4, length.out=200) # possible parameter values for both x and nu

crossing(nu = ps, x=ps) %>%  #every possible combination of nu and x
  mutate(
    likelihood_nu = dnorm(nu, 0, 3),
    likelihood_x  = dnorm(x, 0, exp(nu)),
    joint_likelihood = likelihood_nu*likelihood_x
  ) %>% 
  ggplot( aes(x=x, y=nu, fill=joint_likelihood) ) +
  geom_raster() + 
  scale_fill_viridis_c() +
  guides(fill = F)
  
```


---


The way to fix this is by using an uncentered parameterization:

\begin{align*}
x &= z\times \text{exp}(\nu) \\
z &\sim \text{Normal}(0, 1) \\
\nu &\sim \text{Normal}(0, 3) \\
\end{align*}

```{r}
#| code-fold: true
set.seed(1)
# plot the likelihoods
ps <- seq( from=-4, to=4, length.out=200) # possible parameter values for both x and nu

crossing(nu = ps, z=ps) %>%  #every possible combination of nu and x
  mutate(
    likelihood_nu = dnorm(nu, 0, 3),
    likelihood_z  = dnorm(z, 0, 1),
    joint_likelihood = likelihood_nu*likelihood_z
  ) %>% 
  ggplot( aes(x=z, y=nu, fill=joint_likelihood) ) +
  geom_raster() +
  scale_fill_viridis_c() +
  guides(fill = F)
  
```

---

It's an important point, except the issues of [centered parameterization are so prevalent](https://mc-stan.org/docs/2_18/stan-users-guide/reparameterization-section.html)[^1], that `brms` generally doesn't allow centered parameterization (with some exceptions). So we can't recreate the divergent transition situation that McElreath demonstrates in his lecture. 

[^1]: [this video](https://www.youtube.com/watch?v=gSd1msFFZTw) is a great explanation

McElreath describes the problem of fertility in Bangladesh as such: 

\begin{align*}
C &\sim \text{Bernoulli}(p_i) \\
\text{logit}(p_i) &= \alpha_{D_{[i]}} \\
\alpha_j &\sim \text{Normal}(\bar{\alpha}, \sigma) \\
\bar{\alpha} &\sim \text{Normal}(0, 1) \\
\sigma &\sim \text{Exponential}(1) \\
\end{align*}

But to fit this using `brms`, we'll rewrite as:

\begin{align*}
C &\sim \text{Bernoulli}(p_i) \\
\text{logit}(p_i) &= \alpha + \alpha_{D[i]} \\
\alpha &\sim \text{Normal}(0, 1) \\
\alpha_{D[j]} &\sim \text{Normal}(0, \sigma_{D}) \\
\sigma_{D} &\sim \text{Exponential}(1)
\end{align*}

---


\begin{align*}
C &\sim \text{Bernoulli}(p_i) \\
\text{logit}(p_i) &= \alpha + \alpha_{D[i]} \\
\alpha &\sim \text{Normal}(0, 1) \\
\alpha_{D[j]} &\sim \text{Normal}(0, \sigma_{D}) \\
\sigma_{D} &\sim \text{Exponential}(1)
\end{align*}


```{r}
data(bangladesh, package="rethinking")
d <- bangladesh

m1 <- brm(
  data=d,
  family=bernoulli,
  use.contraception ~ 1 + (1 | district),
  prior = c( prior(normal(0, 1), class = Intercept), # alpha bar
             prior(exponential(1), class = sd)),       # sigma

  chains=4, cores=4, iter=2000, warmup=1000,
  seed = 1,
  file = here("files/data/generated_data/m71.1"))
```

---

```{r}
m1
```

---

```{r}
gather_draws(m1, b_Intercept, r_district[district, ]) %>% 
  with_groups(c(.variable, district), median_qi, .value)
```

---


```{r}
#| code-fold: true

gather_draws(m1, b_Intercept, r_district[district, ]) %>% 
  with_groups(c(.variable, district), median_qi, .value) %>% 
  ggplot(aes( x=district, y=.value)) +
  geom_pointinterval( aes(ymin = .lower, ymax = .upper), 
                      alpha=.5) +
  labs(y="District distance from mean") +
  coord_flip()
```

---

\begin{align*}
C &\sim \text{Bernoulli}(p_i) \\
\text{logit}(p_i) &= \alpha + \alpha_{D[i]} + \beta U_i + \beta_{D[i]}U_i \\
\alpha, \beta &\sim \text{Normal}(0, 1) \\
\alpha_{D[j]} &\sim \text{Normal}(0, \sigma_{D}) \\
\beta_{D[j]} &\sim \text{Normal}(0, \tau_{D}) \\
\sigma, \tau &\sim \text{Exponential}(1) \\
\end{align*}


```{r, message=F}
m2 <- brm(
  data=d,
  family=bernoulli,
  use.contraception ~ 1 + urban + (1 + urban || district),
  prior = c( prior(normal(0, 1), class = Intercept), 
             prior(normal(0, 1), class = b),
             prior(exponential(1), class = sd)),     

  chains=4, cores=4, iter=2000, warmup=1000,
  seed = 1,
  file = here("files/data/generated_data/m71.2"))
```

------------------------------------------------------------------------

Oops, no divergent transitions.

```{r}
m2
```

---

### more about divergent transitions

* [Divergent transitions -- a primer](https://discourse.mc-stan.org/t/divergent-transitions-a-primer/17099)

* [Towards a principled Bayesian workflow](https://betanalpha.github.io/assets/case_studies/principled_bayesian_workflow.html)

* [Bayesian workflow](https://arxiv.org/abs/2011.01808)


---

![](images/7-1_workflow.png)

From Gelman et al [(2020)](https://arxiv.org/abs/2011.01808)

---

## more than one type of cluster

McElreath doesn't cover this in his video lecture, but this is from the textbook and worth discussing.

::::: columns

::: {.column width="50%"}

```{r}
data(chimpanzees, package="rethinking")
d <- chimpanzees
str(d)
```

:::

::: {.column width="50%"}
Data from [Silk et al. (2005)](https://www.nature.com/articles/nature04243)

![](images/7-1_chimp.png)
:::

:::::

:::{.notes}
From McElreath: 

The data for this example come from an experiment aimed at evaluating the prosocial tendencies of chimpanzees (_Pan troglodytes_). The experimental structure mimics many common experiments conducted on human students (_Homo sapiens studiensis_) by economists and psychologists. A focal chimpanzee sits at one end of a long table with two levers, one on the left and one on the right in this figure. On the table are four dishes which may contain desirable food items. The two dishes on the right side of the table are attached by a mechanism to the right-hand lever. The two dishes on the left side are similarly attached to the left-hand lever.

When either the left or right lever is pulled by the focal animal, the two dishes on the same side slide towards opposite ends of the table. This delivers whatever is in those dishes to the opposite ends. In all experimental trials, both dishes on the focal animal’s side contain food items. But only one of the dishes on the other side of the table contains a food item. Therefore while both levers deliver food to the focal animal, only one of the levers delivers food to the other side of the table.

There are two experimental conditions. In the partner condition, another chimpanzee is seated at the opposite end of the table, as pictured in the figure. In the control condition, the other side of the table is empty. Finally, two counterbalancing treatments alternate which side, left or right, has a food item for the other side of the table. This helps detect any handedness preferences for individual focal animals.

When human students participate in an experiment like this, they nearly always choose the lever linked to two pieces of food, the prosocial option, but only when another student sits on the opposite side of the table. The motivating question is whether a focal chimpanzee behaves similarly, choosing the prosocial option more often when another animal is present. In terms of linear models, we want to estimate the interaction between condition (presence or absence of another animal) and option (which side is prosocial).
:::


------------------------------------------------------------------------

```{r}
unique(d$actor)
unique(d$block)
unique(d$prosoc_left)
unique(d$condition)
```


We could model the interaction between condition (presence/absence of another animal) and option (which side is prosocial), but it is more difficult to assign sensible priors to interaction effects. Another option, because we're working with categorical variables, is to turn our 2x2 into one variable with 4 levels. 

```{r}
d$treatment <- factor(1 + d$prosoc_left + 2*d$condition)
d %>% count(treatment, prosoc_left, condition)
```

---

In this experiment, each pull is within a cluster of pulls belonging to an individual chimpanzee. But each pull is also within an experimental block, which represents a collection of observations that happened on the same day. So each observed pull belongs to both an actor (1 to 7) and a block (1 to 6). There may be unique intercepts for each actor as well as for each block.

Mathematical model:

\begin{align*}
L_i &\sim \text{Binomial}(1, p_i) \\
\text{logit}(p_i) &= \bar{\alpha} + \alpha_{\text{ACTOR[i]}} + \bar{\gamma} + \gamma_{\text{BLOCK[i]}} +  \beta_{\text{TREATMENT[i]}} \\
\beta_j &\sim \text{Normal}(0, 0.5) \text{ , for }j=1..4\\
\alpha_j &\sim \text{Normal}(0, \sigma_{\alpha}) \text{ , for }j=1..7\\
\gamma_j &\sim \text{Normal}(0, \sigma_{\gamma}) \text{ , for }j=1..7\\
\bar{\alpha} &\sim \text{Normal}(0, 1.5) \\
\bar{\gamma} &\sim \text{Normal}(0, 1.5) \\
\sigma_{\alpha} &\sim \text{Exponential}(1) \\
\sigma_{\gamma} &\sim \text{Exponential}(1) \\
\end{align*}

----


```{r}
m3 <- 
  brm(
    family = bernoulli,
    data = d, 
    bf(
      pulled_left ~ a + b, 
      a ~ 1 + (1 | actor) + (1 | block), 
      b ~ 0 + treatment, 
      nl = TRUE),
    prior = c(prior(normal(0, 0.5), nlpar = b),
              prior(normal(0, 1.5), class = b, coef = Intercept, nlpar = a),
              prior(exponential(1), class = sd, group = actor, nlpar = a),
              prior(exponential(1), class = sd, group = block, nlpar = a)),
  chains=4, cores=4, iter=2000, warmup=1000,
  seed = 1,
  file = here("files/data/generated_data/m71.3")
  )
```

------------------------------------------------------------------------

```{r}
m3
```

---

```{r}
posterior_summary(m3)
```

---

```{r}
m3 %>% 
  mcmc_plot(variable = c("^r_", "^b_", "^sd_"), regex = T) +
  theme(axis.text.y = element_text(hjust = 0))
```

---

```{r}
#| code-fold: true
as_draws_df(m3) %>% 
  select(starts_with("sd")) %>% 
  pivot_longer(everything()) %>% 
  ggplot(aes(x = value, fill = name)) +
  geom_density(linewidth = 0, alpha = 3/4, adjust = 2/3, show.legend = F) +
  annotate(geom = "text", x = 0.67, y = 2, label = "block", color = "#5e8485") +
  annotate(geom = "text", x = 2.725, y = 0.5, label = "actor", color = "#0f393a") +
  scale_fill_manual(values = c("#0f393a", "#5e8485")) +
  scale_y_continuous(NULL, breaks = NULL) +
  ggtitle(expression(sigma["group"])) +
  coord_cartesian(xlim = c(0, 4))
```

---

### exercise

Return to the `data(Trolley)` from an earlier lecture. Define and fit a varying intercepts model for these data, with responses clustered within participants. Include `action`, `intention`, and `contact.` Compare the varying-intercepts model and the model that ignores individuals using both some method of cross-validation. 

---

### solution

```{r}
data(Trolley, package="rethinking")

# fit model without varying intercepts
m_simple <- brm(
  data = Trolley,
  family = cumulative, 
  response ~ 1 + action + intention + contact, 
  prior = c( prior(normal(0, 1.5), class = Intercept) ),
  iter=2000, warmup=1000, cores=4, chains=4,
  file=here("files/data/generated_data/m71.e1")
)

# fit model with varying intercepts
m_varying <- brm(
  data = Trolley,
  family = cumulative, 
  response ~ 1 + action + intention + contact + (1|id), 
  prior = c( prior(normal(0, 1.5), class = Intercept),
             prior(normal(0, 0.5), class = b),
             prior(exponential(1), class = sd)),
  iter=2000, warmup=1000, cores=4, chains=4,
  file=here("files/data/generated_data/m71.e2")
)
```

---

### solution

```{r}
# compare models using WAIC cross-validation
m_simple  <- add_criterion(m_simple , "loo")
m_varying <- add_criterion(m_varying, "loo")

loo_compare(m_simple, m_varying, criterion = "loo") %>% 
  print(simplify=F)
```

---

```{r}
# posterior predictive check
pp_check(m_simple, ndraws = 5, type="hist") +
  ggtitle("Simple Model")

pp_check(m_varying, ndraws = 5, type="hist") +
  ggtitle("Varying Intercepts Model")
```


---

### predictions

Posterior predictions in multilevel models are a bit more complicated than single-level, because the question arises: predictions for the same clusters or predictions for new clusters?

In other words, do you want to know more about the chimps you collected data on, or new chimps? Let's talk about both. 

**predictions for chimps in our sample**

Recall that the function `fitted()` give predictions. 

```{r}
labels <- c("R/N", "L/N", "R/P", "L/P")

nd <- distinct(d, treatment, actor) %>% 
  mutate(block=1)

f <- fitted(m3,newdata = nd) %>% 
  data.frame() %>% 
  bind_cols(nd) %>% 
  mutate(treatment = factor(treatment, labels = labels))
```

---

```{r}
#| code-fold: true

f %>% 
  ggplot( aes(x=treatment, y=Estimate, group=1) ) +
  geom_ribbon(aes( ymin=Q2.5, ymax=Q97.5 ), 
              fill = "#0f393a",
              alpha=.3) +
  geom_line(color="#0f393a") +
  facet_wrap(~actor)
```

---

```{r}
#| code-fold: true

# observed p
obs = d %>% 
  filter(block==1) %>% 
  group_by(actor, treatment) %>% 
  summarise(p = mean(pulled_left), .groups = "drop") %>% 
  mutate(treatment = factor(treatment, labels = labels))


f %>% 
  ggplot( aes(x=treatment, y=Estimate, group=1) ) +
  geom_ribbon(aes( ymin=Q2.5, ymax=Q97.5 ), 
              fill = "#0f393a",
              alpha=.3) +
  geom_point( aes(y=p), 
              data=obs, 
              shape=1) +
  geom_line(color="#0f393a") +
  facet_wrap(~actor)
```

We can add in the observed probabilities.

---

**predictions for new chimps**

Even here, we have some choice. Let's start by predicting scores for the average chimp. 
```{r}
post <- as_draws_df(m3)
avg_chimp = post %>% select(starts_with("b_")) %>% 
  pivot_longer(-b_a_Intercept) %>% 
  mutate(
    fitted = b_a_Intercept + value,
    fitted = inv_logit_scaled(fitted),
    treatment=factor(str_remove(name, "b_b_treatment"),
                     labels=labels)
  ) %>% 
  group_by(treatment) %>% 
  median_qi(fitted)
avg_chimp
```

---

```{r}
#| code-fold: true

f %>% 
  ggplot( aes(x=treatment, y=Estimate, group=1) ) +
  geom_ribbon(aes( ymin=Q2.5, ymax=Q97.5 ), 
              fill = "#0f393a",
              alpha=.3) +
  geom_point( aes(y=p), 
              data=obs, 
              shape=1) +
  geom_line(color="#0f393a") +
  geom_ribbon(aes( x=treatment, ymin=.lower, ymax=.upper ), 
              alpha=.3,
              fill="#e07a5f",
              data=avg_chimp,
              inherit.aes = F) +
  geom_line( aes(y=fitted), data=avg_chimp, color ="#e07a5f") +
  geom_line(color="#0f393a") +
  facet_wrap(~actor)
```

---

But the average chimp is only one possible chimp we could encounter. Let's simulate 100 possible chimps.

```{r}
#| code-fold: true

post %>% 
  slice_sample(n=100) %>% 
  # simulate chimps
  mutate(a_sim = rnorm(n(), mean = b_a_Intercept, sd = sd_actor__a_Intercept)) %>% 
  pivot_longer(b_b_treatment1:b_b_treatment4) %>% 
  mutate(fitted = inv_logit_scaled(a_sim + value)) %>% 
  mutate(treatment = factor(str_remove(name, "b_b_treatment"),
                            labels = labels)) %>%
  ggplot(aes(x = treatment, y = fitted, group = .draw)) +
  geom_line(alpha = 1/2, color = "#e07a5f") +
  coord_cartesian(ylim = 0:1) 
```

---

### exercise

Returning to the Trolley data and the varying intercept model, get predictions for...

1. a subset of 3 participants in the dataset. 
2. the average participant.
3. 2 new participants.

Hint: don't forget that the model uses a link function. You may need to play with arguments or fiddle around with the outputs of your functions. 

---

### solution

3 participants

```{r}
#| code-fold: true

part3 = sample( unique(Trolley$id) , size=3, replace=F )
nd <- distinct(Trolley, action, intention, contact, id) %>% 
  filter(id %in% part3)

f <- fitted(m_varying, newdata = nd, scale = "response") %>% 
  data.frame() %>% 
  bind_cols(nd) 

f %>% 
  pivot_longer(-c(action:id),
               names_sep = "\\.{3}",
               names_to = c("stat", "response")) %>% 
  pivot_wider(names_from = stat, values_from = value) %>% 
  mutate(response = str_sub(response, 1, 1)) %>% 
  ggplot(aes(x=response, y=Estimate.P.Y, fill=as.factor(intention))) +
  geom_bar(stat="identity", position="dodge") +
  labs(y="p") +
  facet_grid(action+contact~id) +
  theme(legend.position = "bottom")
```

---

### solution

The average participant 

```{r}
#| code-fold: true

nd <- distinct(Trolley, action, intention, contact) 

f <- fitted(m_varying, newdata = nd, scale = "response", 
            re_formula = NA) %>% 
  data.frame() %>% 
  bind_cols(nd) 

f %>% 
  pivot_longer(-c(action:contact),
               names_sep = "\\.{3}",
               names_to = c("stat", "response")) %>% 
  pivot_wider(names_from = stat, values_from = value) %>% 
  mutate(response = str_sub(response, 1, 1)) %>% 
  ggplot(aes(x=response, y=Estimate.P.Y, fill=as.factor(intention))) +
  geom_bar(stat="identity", position="dodge") +
  labs(y="p") +
  facet_grid(action~contact) +
  theme(legend.position = "bottom")
```

---

Two new participants

```{r}
# create data for 2 new participants
nd <- distinct(Trolley, action, intention, contact) %>%
  slice(rep(1:n(), times = 2)) %>%
  mutate(id = rep(c("New1", "New2"), each = n()/2))

# get predictions including random effects
f <- fitted(m_varying, newdata = nd, 
            scale = "response", allow_new_levels=T) %>% 
  data.frame() %>% 
  bind_cols(nd) 

# plot
f %>% 
  pivot_longer(-c(action:id),
               names_sep = "\\.{3}",
               names_to = c("stat", "response")) %>% 
  pivot_wider(names_from = stat, values_from = value) %>% 
  mutate(response = str_sub(response, 1, 1)) %>% 
  ggplot(aes(x=response, y=Estimate.P.Y, fill=as.factor(intention))) +
  geom_bar(stat="identity", position="dodge") +
  labs(y="p", fill="intention") +
  facet_grid(action+contact~id) +
  theme(legend.position = "bottom")
```

